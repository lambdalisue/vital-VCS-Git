let s:V = vital#of('vital')
let s:P = s:V.import('System.Filepath')
let s:L = s:V.import('Data.List')
call s:V.unload() " make sure that the following modules are not cached version
let s:G = s:V.import('VCS.Git')

Describe VCS.Git
  Before all
    " Create a mock Git working tree
    let root = tempname()
    let worktree = s:P.join(root, 'inside')
    let repository = s:P.join(worktree, '.git')
    let inside = s:P.join(worktree, 'foo', 'bar')
    let outside = s:P.join(root, 'outside', 'foo', 'bar')
    lockvar root
    lockvar worktree
    lockvar repository
    lockvar inside
    lockvar outside
    call mkdir(repository, 'p')
    call mkdir(inside, 'p')
    call mkdir(outside, 'p')

    call writefile([], s:P.join(repository, 'index'))
  End

  After all
    " remote a temp directory
    call s:V.import('System.File').rmdir(root, 'r')
  End

  Context .new({worktree}, {repository})
    It should return a Git instance
      let ret = s:G.new(worktree, repository)
      Assert IsDict(ret)
      Assert KeyExists(ret, 'worktree')
      Assert KeyExists(ret, 'repository')
      Assert KeyExists(ret, 'cache')
    End

    It should return a same Git instance for same worktree
      let ret1 = s:G.new(worktree, repository)
      let ret2 = s:G.new(worktree, repository)
      Assert Same(ret1, ret2)
    End

    It should return a different Git instance for same worktree if 'no_cache' is specified
      let ret1 = s:G.new(worktree, repository)
      let ret2 = s:G.new(worktree, repository, { 'no_cache': 1 })
      Assert NotSame(ret1, ret2)
    End


    It should return a different Git instance for different worktree
      let ret1 = s:G.new(worktree, repository)
      let ret2 = s:G.new(outside, repository)
      Assert NotSame(ret1, ret2)
    End
  End

  Context .find({path})
    It should return a Git instance for a directory which locate inside a Git worktree
      let path = inside
      let exp = s:G.new(worktree, repository)
      let ret = s:G.find(path)
      Assert Same(ret, exp)
    End

    It should return a same Git instance for directories which locate inside a same Git worktree
      let path1 = inside
      let path2 = s:P.join(inside, 'piyo')
      let ret1 = s:G.find(path1)
      let ret2 = s:G.find(path2)
      Assert Same(ret1, ret2)
    End

    It should return an empty dictionary for non git directory
      let path = outside
      let ret = s:G.find(path)
      Assert True(empty(ret))
    End
  End

  Context instance
    Before
      " newly create a Git instance
      let s:git = s:G.new(worktree, repository, { 'no_cache': 1 })

      function! s:git.patch_get_index_updated_time()
        function! self.get_index_updated_time()
          return reltime()[0] + 1000
        endfunction
      endfunction
    End

    Context .get_index_updated_time()
      It should return a number which indicate an updated time of the repository
        let ret = s:git.get_index_updated_time()
        Assert IsNumber(ret)
        Assert NotEquals(ret, -1, 'an ".git/index" file is not found')
      End
    End

    Context .get_parsed_status()
      It should return a dictionary which indicate the parsed current repository status
        let ret = s:git.get_parsed_status()
        Assert IsDict(ret)
      End

      It should return a same dictionary if the repository is not updated
        let ret1 = s:git.get_parsed_status()
        let ret2 = s:git.get_parsed_status()
        Assert Same(ret1, ret2)
      End

      It should return a different dictionary if the repository is updated
        let ret1 = s:git.get_parsed_status()
        call s:git.patch_get_index_updated_time()
        let ret2 = s:git.get_parsed_status()
        Assert NotSame(ret1, ret2)
      End

      It should return a different dictionary if different option is specified
        let ret1 = s:git.get_parsed_status()
        let ret2 = s:git.get_parsed_status({ 'branch': 1 })
        Assert NotSame(ret1, ret2)
      End
    End

    Context .get_parsed_commit()
      It should return a dictionary which indicate the parsed current repository commit
        let ret = s:git.get_parsed_commit()
        Assert IsDict(ret)
      End

      It should return a same dictionary if the repository is not updated
        let ret1 = s:git.get_parsed_commit()
        let ret2 = s:git.get_parsed_commit()
        Assert Same(ret1, ret2)
      End

      It should return a different dictionary if the repository is updated
        let ret1 = s:git.get_parsed_commit()
        call s:git.patch_get_index_updated_time()
        let ret2 = s:git.get_parsed_commit()
        Assert NotSame(ret1, ret2)
      End

      It should return a different dictionary if different option is specified
        let ret1 = s:git.get_parsed_commit()
        let ret2 = s:git.get_parsed_commit({ 'amend': 1 })
        Assert NotSame(ret1, ret2)
      End
    End

    Context .get_parsed_config()
      It should return a dictionary which indicate the parsed Git config
        let ret = s:git.get_parsed_config()
        Assert IsDict(ret)
      End

      It should return a same dictionary if the repository is not updated
        let ret1 = s:git.get_parsed_config()
        let ret2 = s:git.get_parsed_config()
        Assert Same(ret1, ret2)
      End

      It should return a different dictionary if the repository is updated
        let ret1 = s:git.get_parsed_config()
        call s:git.patch_get_index_updated_time()
        let ret2 = s:git.get_parsed_config()
        Assert NotSame(ret1, ret2)
      End

      It should return a different dictionary if 'args' option is specified
        let ret1 = s:git.get_parsed_config()
        let ret2 = s:git.get_parsed_config({ 'local': 1 })
        Assert NotSame(ret1, ret2)
      End
    End

    Context .get_meta()
      It should return a dictionary which indicate the meta information of the Git repository
        let ret = s:git.get_meta()
        Assert KeyExists(ret, 'head')
        Assert KeyExists(ret, 'fetch_head')
        Assert KeyExists(ret, 'orig_head')
        Assert KeyExists(ret, 'merge_head')
        Assert KeyExists(ret, 'merge_mode')
        Assert KeyExists(ret, 'commit_editmsg')
        Assert KeyExists(ret, 'merge_msg')
        Assert KeyExists(ret, 'current_branch')
        Assert KeyExists(ret, 'repository_config')
        Assert KeyExists(ret, 'current_branch_remote')
        Assert KeyExists(ret, 'current_branch_merge')
        Assert KeyExists(ret, 'current_remote_url')
        Assert KeyExists(ret, 'comment_char')
      End

      It should exclude repository config related keys in the return dictionary if 'exclude_repository_config' is specified
        let ret = s:git.get_meta({ 'exclude_repository_config': 1 })
        Assert IsDict(ret)
        Assert KeyExists(ret, 'head')
        Assert KeyExists(ret, 'fetch_head')
        Assert KeyExists(ret, 'orig_head')
        Assert KeyExists(ret, 'merge_head')
        Assert KeyExists(ret, 'merge_mode')
        Assert KeyExists(ret, 'commit_editmsg')
        Assert KeyExists(ret, 'merge_msg')
        Assert KeyExists(ret, 'current_branch')
        Assert KeyNotExists(ret, 'repository_config')
        Assert KeyNotExists(ret, 'current_branch_remote')
        Assert KeyNotExists(ret, 'current_branch_merge')
        Assert KeyNotExists(ret, 'current_remote_url')
        Assert KeyNotExists(ret, 'comment_char')
      End
    End
  End

  Context .get_relative_path({path})
    It should return a relative path of an absolute {path}
      let path = inside
      let exp = s:P.join(['foo', 'bar'])
      let ret = s:git.get_relative_path(path)
      Assert Equals(ret, exp)
    End

    It should return a {path} if {path} is not absolute path
      let path = s:P.join(['foo', 'bar'])
      let exp = path
      let ret = s:git.get_relative_path(path)
      Assert Equals(ret, exp)
    End
  End

  Context .get_absolute_path({path})
    It should return an absolute path of a relative {path}
      let path = s:P.join(['foo', 'bar'])
      let exp = inside
      let ret = s:git.get_absolute_path(path)
      Assert Equals(ret, exp)
    End

    It should return a {path} if {path} is not relative path
      let path = inside
      let exp = path
      let ret = s:git.get_absolute_path(path)
      Assert Equals(ret, exp)
    End
  End

  Context .exec({args} [, {opts}])
    Before
      let previous_cwd = getcwd()
    End
    After
      silent execute 'lcd ' previous_cwd
    End

    It should execute git command on a top directory of the worktree
      silent execute printf('!git init -q %s', worktree)
      silent execute 'lcd ' inside

      let result = s:git.exec(['rev-parse', '--show-toplevel'])
      let expect = {
            \ 'status': 0,
            \ 'stdout': printf("%s", worktree),
            \ 'args': ['git', '-c', 'color.ui=false', 'rev-parse', '--show-toplevel'],
            \ 'opts': {'stdin': '', 'timeout': 0, 'cwd': worktree},
            \}
      Assert Equals(result, expect)
    End
  End
End
